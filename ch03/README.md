# 3장: 인덱스 튜닝

## 3.1 테이블 액세스 최소화
- 테이블 랜덤 액세스가 성능에 미치는 영향

### 3.1.1 테이블 랜덤 액세스
#### **인덱스에 대한 맹신 또는 섣부른 자신감**
인덱스를 사용하면 빠르다고 생각되었던 것이 대량 데이터를 조회하는 순간 테이블 전체를 스캔할 때 보다 느려지는 경우가 있다. 이러한 이유에 대해 알아보자.

#### **인덱스 ROWID는 물리적 주소? 논리적 주소?**
* 인덱스를 스캔하는 이유?
  * 검색 조건을 만족하는 소량의 데이터를 빨리 찾아 테이블 레코드를 찾아가기 위한 주소값(ROWID)을 얻기 위해

* 인덱스 ROWID는 물리적 주소보다 논리적 주소에 가깝다.
  * 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문
  * C의 포인터와 같이 직접적인 물리주소를 담고 있지 않다.

> ROWID는 도서 색인에 비유하자면 색인에 기록된 페이지 번호로 볼 수 있다.

#### **메인 메모리 DB와 비교**
- 메인 메모리 DB
  - 인스턴스 기동시 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 인덱스를 생성
  - 디스크 상의 주소정보를 갖는 게 아닌 메모리상의 주소정보(포인터)를 가짐
  - 인덱스를 경유하고 테이블을 액세스하는 비용이 디스크 DB와 비교해 매우 낮다.

디스크 DB는 포인터가 아닌 디스크 주소 정보(DBA, Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

#### **I/O 메커니즘 복습**
- DBA(데이터 파일 번호 + 블록 번호)는 디스크 상에서 블록을 찾기 위한 주소 정보
- I/O 성능을 높이기 위해 버퍼캐시를 잘 활용

1. 블록을 읽을 때 디스크로 가기 전 버퍼캐시를 체크한다.
2. 읽고자 하는 DBA를 해시 함수에 입력해 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
3. 버퍼 헤더는 항상 같은 해시 체인에 연결
4. 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱
   * 메모리 주소값을 버퍼 헤더가 가지고 있다.

해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾아간다.

* 인덱스로 테이블 블록을 액세스할 때
  1. 리프 블록에서 읽은 ROWID를 분해
  2. DBA 정보 획득
* 테이블을 Full Scan 할 때
  1. 익스텐트 맵을 통해 블록들의 DBA 정보 획득

#### **인덱스 ROWID는 우편주소**