# 1장: SQL 처리 과정과 I/O
- `옵티마이저`가 SQL을 어떻게 처리하는지
- 서버 프로세스는 데이터를 어떻게 읽고 저장하는지

## 1.1 SQL 파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
- SQL(Structed Query Language: 구조적 질의 언어)
    - 구조적(structed)
    - 집합적(set-based)
    - 선언적(declarative)

SQL은 원하는 결과집합을 구조적, 집합적으로 선언하는데 이 때 결과집합을 만드는 과정에서 절차적인 `프로시저`가 필요하다.
> `프로시저(Procedure)`란 어떤 업무를 수행하기 위한 절차이다. 즉, 프로세스를 절차적으로 기술해 놓은 것

`프로시저`는 DBMS 내부 엔진이 만들어내고 DBMS 내부 엔진을 `옵티마이저`라고 한다.
사용자 --> (SQL) --> `옵티마이저` --> (실행계획) --> `프로시저`

DBMS 내부에서 `프로시저`를 작성하고 컴파일해서 실행 가능한 상태로 만드는 과정을 'SQL 최적화'라고 한다.

### 1.1.2 SQL 최적화

SQL의 최적화 과정은 다음과 같다.

1. SQL 파싱
   
   SQL Parser가 파싱을 진행한다.
   - 파싱 트리 생성: SQL 문을 이루는 개별 구성요소를 분석
   - Syntax 체크: 문법 오류 체크
     - 예시1) 사용할 수 없는 키워드 사용
   - Semantic 체크: 의미상 오류가 없는지 확인
     - 예시1) 존재하지 않는 테이블 또는 컬럼을 사용하는지
     - 예시2) 오브젝트에 대한 권한이 있는지
2. SQL 최적화
    - `옵티마이저`의 역할
    - 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성 후 가장 효율적인 하나를 선택
3. 로우 소스 생성 
    - 로우 소스 생성기(Row-Source Generator)의 역할
    - SQL 최적화 단계에서 선택한 실행경로를 실제 실행 가능한 코드 또는 `프로시저` 형태로 포맷팅


### 1.1.3 SQL 옵티마이저
사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진

1. 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾는다.
2. Data Dictionary에 미리 수집해 둔 오브젝트 통계 및 시스템 정보를 이용해 각 실행계획의 예상비용을 산정
3. 그 중 최저비용인 실행계획을 선택한다.


### 1.1.4 실행계획과 비용
네비게이션의 기능과 같이 여러 경로를 검색해 미리 확인하는 것과 비슷하다고 볼 수 있다.

- 옵티마이저는 비용(Cost)을 보고 선택한다.
- I/O 횟수 또는 예상 소요시간을 기반으로 산정
- **어디까지나 통계정보를 활용한 예측값이기 때문에 실측치가 아니다.**
> DBMS에도 'SQL 실행경로 미리보기' 기능이 있다.
  
### 1.1.5 옵티마이저 힌트
네비게이션이 추천하는 길이 항상 최선이 아닐 때도 있다.

운전자의 경험을 활용해 더 빨리 목적지에 도착할 수 있는 것 처럼 개발자가 직접 더 효율적인 액세스 경로를 찾아내 데이터 액세스 경로를 바꿀 수 있다.

이럴 때 `옵티마이저 힌트`를 이용한다.

* 힌트 사용법 
  * 주석 기호에 `+`를 붙인다.
    ```SQL
    SELECT /*+ INDEX(A 고객_PK) */
        고객명, 연락처, 주소, 가입일시
    FROM 고객 A
    WHERE 고객ID = '00001'
    ```
  * 주의사항
    ```SQL
    /*+ INDEX(A A_X01) INDEX(B, B_X03) */ ->  모두 유효
    /*+ INDEX(C), FULL(D) */ -> 첫 번째 힌트만 유효
    ```

옵티마이저에게 특정 부분은 개발자가 직접 선택하고, 나머지는 옵티마이저에게 맡기는 식으로 지시를 할 수 있다.
1. 액세스 방식만 지정
2. 액세스 방식, 조인 방식과 순서 모두 지정

#### 자주 사용하는 힌트 목록


## 1.2 SQL 공유 및 재사용
- 소프트 파싱과 하드 파싱의 차이점 설명

### 1.2.1 소프트 파싱 vs 하드 파싱

* Soft Parsing
  1. SQL 파싱 
  2. 캐시에 존재
  3. 곧바로 실행
* Hard Parsing
  1. SQL 파싱 
  2. 캐시에 존재하지 않음
  3. 최적화
  4. 로우 소스 생성


SQL 최적화 과정에서 어떤 조인을 사용할지 순서는 어떻게 할지만 계산해도 굉장히 많은 경우의 수가 계산이 된다.
이 과정에서 `옵티마이저`가 사용한느 정보는 다음과 같다.
- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계: CPU 속도, Single Block I/O 속도, MultiBlock I/O 속도 등
- 옵티마이저 관련 파라미터

짧은 시간에 이 많은 정보를 참조해 효율성을 판단하는 과정은 가볍지 않고 굉장히 무겁다.
이렇게 어려운 작업을 통해 생성된 프로시저를 한 번 사용 후 버린다면 굉장히 비효율적이기 때문에 `Library Cache`를 사용한다.

> SQL 최적화 과정을 거쳐 생성한 내부 `프로시저`를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 `Library Cache`라고 한다.

`Library Cache`는 SGA의 구성요소이다.
* SGA(System Global Area)
  - 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간

### 1.2.2 바인드 변수의 중요성
#### 이름없는 SQL 문제
SQL은 사용자 정의 함수/프로시저, 트리거, 피키지 등과 다르게 이름이 없고 SQL 자체가 이름이다.

SQL의 텍스트가 조금이라도 변경되면 SQL ID도 변한다.
SQL ID도 SQL의 전체 텍스트를 간략히 표현하기 위한 내부 함수를 이용해 생성한 값이다. 

즉, SQL 전체 텍스트와 SQL ID는 1:1 대응 관계이다.

#### 공유 가능 SQL
```SQL
SELECT * FROM emp WHERE empno = 7900;

select * from EMP where EMPNO = 7900;

select * from emp where empno = 7900;
```

같은 결과여도 위에서 말했듯이 SQL 텍스트값 자체가 ID이기 때문에 위 3개의 SQL은 모두 다르다.

실행할 때 각각 최적화를 진행하고 `Library Cache`에서 별도 공간을 사용한다.

```java
String sql = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id + "'";
```
위와 같은 쿼리를 소스에 작성했다고 하자.
대용량 트래픽으로 여러 loginId값이 들어오면 라이브러리 캐시에 발생하는 여러 종류의 경합 때문에 부하가 생긴다. 이유는 로그인 할 때마다 DBMS 내부 프로시저를 하나씩 생성해서 캐시에 적재하게 되는 셈이기 때문이다.

* 올바른 방법 (파라미터 Driven 방식)
    ```SQL
    create procedure LOGIN (login_id in varchar2) { ... }
    ```
    `바인드 변수`를 사용해서 처리하게 되면 라이브러리 캐시에는 로그인 관련해서 여러개가 아닌 하나의 SQL만 발견된다.
    
    ```SQL
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
    ```

    이렇게 **캐싱된 SQL을 여러 유저가 공유하면서 재사용 할 수 있다**.

## 1.3 데이터 저장 구조 및 I/O 메커니즘
- I/O에 대한 이해
- 데이터 저장 구조, 디스크 및 메모리에서 데이터를 읽는 메커니즘

### 1.3.1 SQL이 느린 이유
결론적으로는 디스크 I/O 문제이다.
OS 또는 서브시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다.

> Process는 생성(new) 이후 종료(terminated) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복한다.

I/O가 많이 발생하면 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시 실행 상태로 전환하는 과정에서 대기 상태가 많아지고 결국 느려지게 된다.

### 1.3.2 데이터베이스 저장 구조

